<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">


<!-- Begin Jekyll SEO tag v2.7.1 -->
<title>Dr. Pascal Weisenburger | Programming Group</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="Dr. Pascal Weisenburger" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Profile of Dr. Pascal Weisenburger, Postdoctoral Researcher at the Programming Group." />
<meta property="og:description" content="Profile of Dr. Pascal Weisenburger, Postdoctoral Researcher at the Programming Group." />
<link rel="canonical" href="https://programming-group.com/members/weisenburger" />
<meta property="og:url" content="https://programming-group.com/members/weisenburger" />
<meta property="og:site_name" content="Programming Group" />
<meta property="og:image" content="https://programming-group.com/assets/img/og/pg.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2021-12-06T10:04:03+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://programming-group.com/assets/img/og/pg.png" />
<meta property="twitter:title" content="Dr. Pascal Weisenburger" />
<meta name="google-site-verification" content="RMUCoHAseeFv2jAdfyJb4XLx4e1J8XpU1l8fvwAxk1g" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://programming-group.com/members/weisenburger"},"description":"Profile of Dr. Pascal Weisenburger, Postdoctoral Researcher at the Programming Group.","image":"https://programming-group.com/assets/img/og/pg.png","headline":"Dr. Pascal Weisenburger","dateModified":"2021-12-06T10:04:03+00:00","datePublished":"2021-12-06T10:04:03+00:00","url":"https://programming-group.com/members/weisenburger","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->


<!-- Styles -->
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="stylesheet" href="/assets/css/bundle-1e30bbe54ea0bcfc79fd9ff0bac804df.css">
<link rel="stylesheet" href="/assets/css/main.css?v=46f9c16dd5756ebad53917c1ca1d01b49e2ac026" />

  </head>

  <body class="fixed-top-nav sticky-bottom-footer">

    <!-- Header -->

    <header class="fixed-top">

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand">
    <div class="container px-md-3">
      <a href="/" class="">
        <img src="/assets/img/pg-logo.svg" alt="Programming Group"/>
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-wrap">
          <!-- About -->
          
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/">
                Home
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/team">
                Team
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/teaching">
                Teaching
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/publications">
                Publications
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/open-positions">
                Open Positions
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link text-nowrap" href="/contact">
                Contact
                
              </a>
          </li>
          
          
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      <div class="post">

  <header class="post-header">
    <span class="social-header float-right">
  <a href="mailto:%67%75%69%64%6F.%73%61%6C%76%61%6E%65%73%63%68%69@%75%6E%69%73%67.%63%68"><i class="fas fa-envelope"></i></a>
  
  
  
  
  
  
  <a href="https://twitter.com/prg_grp" target="_blank" title="Twitter"><i class="fab fa-twitter"></i></a>
  <a href="https://www.youtube.com/channel/UCW60aqeksbbWTT-7sR6G97w" target="_blank" title="YouTube"><i class="fab fa-youtube"></i></a>
  
  
  
  
  
  
  
</span>

    <h1 class="post-title">
     Dr. Pascal Weisenburger
    </h1>
      
  </header>

  <article>
    
    <div class="profile float-right">
      
        
          <img class="img-fluid z-depth-1 rounded" src="/assets/img/weisenburger-profile.jpg" alt="Dr. Pascal Weisenburger">
        
      
      
        <div class="address">
          <p>
            
              <span class="name">Dr. Pascal Weisenburger</span>
            
            
            <br /><a href="mailto:pascal.weisenburger@unisg.ch"><i class="fas fa-envelope"></i> pascal.weisenburger@unisg.ch</a>
            
            <br /><a href="https://orcid.org/0000-0003-1288-1485" target="_blank"><i class="fab fa-orcid"></i> 0000-0003-1288-1485</a>
            
            <br /><a href="https://github.com/pweisenburger" target="_blank"><i class="fab fa-github"></i> pweisenburger</a>
            
          </p>
          <p class="post">School of Computer Science<br /> Torstrasse 25<br /> 9000 St. Gallen, Switzerland
</p>
        </div>
      
    </div>
    

    <div class="clearfix">
      <p>My current research focuses on the design of languages for distributed systems
with a wide range of software architectures – e.g., peer-to-peer, cloud, edge, serverless, IoT –
regarding areas such as sound programming models for the interaction between components,
their composition, privacy protection issues,
type systems for reasoning about the placement of data and computation.</p>

<p>Within the <a href="https://www.maki.tu-darmstadt.de/" target="_blank">MAKI</a> project,
I worked on complex event processing (CEP)
and multitier languages for developing modular distributed applications.
I’m the main developer of the <a href="/projects/scala-loci">ScalaLoci</a>
multitier programming language.</p>

<p>I served in the program committee of <a href="https://2020.programming-conference.org/home/proweb-2020" target="_blank">ProWeb 2020</a>
(Workshop on Programming Technology for the Future Web)
at ‹Programming› ’20.</p>

<h2 id="short-bio">Short Bio</h2>

<p>I got my PhD from the Departement of Computer Science at the Technical University of Darmstadt
under the supervision of Prof. Guido Salvaneschi in 2020.
My doctoral dissertation focuses on multitier programming
for developing distributed software systems.
I worked as a postdoc with Prof. Mira Mezini at the Technical University of Darmstadt until spring 2021.
I joined the Programming Group at the University of St. Gallen in May 2021.</p>


        
    </div>

    

    

    

    

    
      <h2 id="publications">Publications</h2>
      <div class="publications">
        <ol class="bibliography"><li><div class="row">


  <div id="Sokolowski:2021:EssentialSafety" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ICSE</abbr><br />
              
          
          
      </div>
      <div class="title">Change Is the Only Constant: Efficient Dynamic Updates for Workflows with Essential Safety</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 44th International Conference on Software Engineering</em>, ICSE, 2022
      
      </div>
    

    <div class="links">
    
    
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Luthra:2021:TCEP" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">JCSS</abbr><br />
              
          
          
      </div>
      <div class="title">TCEP: Transitions in Operator Placement to Adapt to Dynamic Network Environments</div>
      <div class="author">
        
          
          
          
          

          
            
              Manisha Luthra, 
            
          
        
          
          
          
          

          
            
              Boris Koldehofe, 
            
          
        
          
          
          
          

          
            
              Niels Danger, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Ioannis Stavrakakis
            
          
        
      </div>

      <div class="periodical">
      
        <em>Journal of Computer and System Sciences</em> 122, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_TCEP-Transitions-in-Operator-Placement-to-Adapt-to-Dynamic-Network-Environments.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1016/j.jcss.2021.05.003" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed Complex Event Processing (DCEP) is a commonly used paradigm to detect and act on situational changes of many applications, including the Internet of Things (IoT). DCEP achieves this using a simple specification of analytical tasks on data streams called operators and their distributed execution on a set of infrastructure. The adaptivity of DCEP to the dynamics of IoT applications is essential and very challenging in the face of changing demands concerning Quality of Service. In our previous work, we addressed this issue by enabling transitions, which allow for the adaptive use of operator placement mechanisms. In this article, we extend the transition methodology by optimizing the costs of transition and analyzing the behavior using multiple operator placement mechanisms. Furthermore, we provide an extensive evaluation on the costs of transition imposed by operator migrations and learning, as it can inflict overhead on the performance if operated uncoordinatedly.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Sokolowski:2021:Automating" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ESEC/FSE</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/mjuz">µs <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Automating Serverless Deployments for DevOps Organizations</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/sokolowski">Daniel Sokolowski</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 29th ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering</em>, ESEC/FSE, 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Automating-Serverless-Deployments-for-DevOps-Organizations.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3468264.3468575" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
      
      <a href="https://doi.org/10.5281/zenodo.4888908" class="btn btn-sm z-depth-0" role="button" target="_blank">Supp</a>
      
    
    
    
      <a href="https://github.com/mjuz-iac/mjuz" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>DevOps unifies software development and operations in cross-functional teams to improve software delivery and operations (SDO) performance. Ideally, cross-functional DevOps teams independently deploy their services, but the correct operation of a service often demands other services, requiring coordination to ensure the correct deployment order. This issue is currently solved either with a central deployment or manual out-of-band communication across teams, e.g., via phone, chat, or email. Unfortunately, both contradict the independence of teams, hindering SDO performance – the reason why DevOps is adopted in the first place.</p><p>In this work, we conduct a study on 73 IT professionals, showing that, in practice, they resort to manual coordination for correct deployments even if they expect better SDO performance with fully automated approaches. To address this issue, we propose μs ([mju:z] “muse”), a novel IaC system automating deployment coordination in a fully decentralized fashion, still retaining compatibility with DevOps practice – in contrast to today’s solutions. We implement µs, demonstrate that it effectively enables automated coordination, introduces negligible definition overhead, has no performance overhead, and is broadly applicable, as shown by the migration of 64 third-party IaC projects.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Giallorenzo:2021:Multiparty" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multiparty Languages: The Choreographic and Multitier Cases</div>
      <div class="author">
        
          
          
          
          

          
            
              Saverio Giallorenzo, 
            
          
        
          
          
          
          

          
            
              Fabrizio Montesi, 
            
          
        
          
          
          
          

          
            
              Marco Peressotti, 
            
          
        
          
          
          
          

          
            
              David Richter, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 35th European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2021
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2021_Multiparty-Languages-The-Choreographic-and-Multitier-Cases.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2021.22" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Choreographic languages aim to express multiparty communication protocols, by providing primitives that make interaction manifest. Multitier languages enable programming computation that spans across several tiers of a distributed system, by supporting primitives that allow computation to change the location of execution. Rooted into different theoretical underpinnings—respectively process calculi and lambda calculus—the two paradigms have been investigated independently by different research communities with little or no contact. As a result, the link between the two paradigms has remained hidden for long.</p><p>In this paper, we show that choreographic languages and multitier languages are surprisingly similar. We substantiate our claim by isolating the core abstractions that differentiate the two approaches and by providing algorithms that translate one into the other in a straightforward way. We believe that this work paves the way for joint research and cross-fertilisation among the two communities.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Köhler:2020:Rethinking" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/consyst">ConSysT <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Rethinking Safe Consistency in Distributed Object-Oriented Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/eskandani">Nafise Eskandani</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Alessandro Margara, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 4 (OOPSLA), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_Rethinking-Safe-Consistency-In-Distributed-Object-Oriented-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3428256" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Large scale distributed systems require to embrace the trade off between consistency and availability, accepting lower levels of consistency to guarantee higher availability. Existing programming languages are, however, agnostic to this compromise, resulting in consistency guarantees that are the same for the whole application and are implicitly adopted from the middleware or hardcoded in configuration files.</p><p>In this paper, we propose to integrate availability in the design of an object-oriented language, allowing developers to specify different consistency and isolation constraints in the same application at the granularity of single objects. We investigate how availability levels interact with object structure and define a type system that preserves correct program behavior. Our evaluation shows that our solution performs efficiently and improves the design of distributed applications.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2020:Survey" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">CSUR</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">A Survey of Multitier Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Johannes Wirth, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>ACM Computing Surveys</em> 53 (4), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_A-Survey-of-Multitier-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3397495" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Multitier programming deals with developing the components that pertain to different tiers in the system (e.g., client and server), mixing them in the same compilation unit. In this paradigm, the code for different tiers is then either generated at run time or it results from the compiler splitting the codebase into components that belong to different tiers based on user annotations, static analysis, types, or a combination of these. In the Web context, multitier languages aim at reducing the distinction between client and server code, by translating the code that is to be executed on the clients to JavaScript or by executing JavaScript on the server, too. Ultimately, the goal of the multitier approach is to improve program comprehension, simplify maintenance and enable formal reasoning about the properties of the whole distributed application.</p><p>A number of multitier research languages have been proposed over the last decade, which support various degrees of multitier programming and explore different design tradeoffs. In this article, we provide an overview of the existing solutions, discuss their positioning in the design space, and outline open research problems.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2020:Implementing" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">‹Programming›</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Implementing a Language for Distributed Systems: Choices and Experiences with Type Level and Macro Programming in Scala</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>The Art, Science, and Engineering of Programming</em> 4 (3), 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2020_Implementing-a-Language-for-Distributed-Systems.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.22152/programming-journal.org/2020/4/17" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
      <a href="https://github.com/scala-loci" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
      <a href="https://scala-loci.github.io/" class="btn btn-sm z-depth-0" role="button" target="_blank">Website</a>
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Multitier programming languages reduce the complexity of developing distributed systems by developing the distributed system in a single coherent code base. The compiler or the runtime separate the code for the components of the distributed system, enabling abstraction over low level implementation details such as data representation, serialization and network protocols. Our ScalaLoci language allows developers to declare the different components and their architectural relation at the type level, allowing static reasoning about about distribution and remote communication and guaranteeing static type safety across components. The compiler splits the multitier program into the component-specific code and automatically generates the communication boilerplate. Communication between components can be modeled by declaratively specifying data flows between components using reactive programming.</p><p>In this paper, we report on the implementation of our design and our experience with embedding our language features into Scala as a host language. We show how a combination of Scala’s advanced type level programming and its macro system can be used to enrich the language with new abstractions. We comment on the challenges we encountered and the solutions we developed for our current implementation and outline suggestions for an improved macro system to support the such use cases of embedding of domain-specific abstractions.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2020:Programming" class="col-sm-12">
    
      <div class="abbr">
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">A Programming Language for Distributed Systems</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>
            
          
        
      </div>

      <div class="periodical">
      
          Doctoral dissertation, <em>Technische Universität Darmstadt</em>, 2020
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
    
      <a href="https://doi.org/10.25534/tuprints-00013500" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Today’s software, including many everyday services, such as online streaming, search engines and social networks, is widely distributed, running on top of a network of interconnected computers. Such distributed applications are traditionally developed as separate modules for each component in the distributed system. These modules react to events, like user input or messages from the network, and in turn produce new events for the other modules. Separation into different modules is problematic because combining modules is notoriously hard and requires extensive and time-consuming integration and manual implementation of communication forces programmers to program complex event-based communication schemes among hosts ? an activity which is often low-level and error-prone. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. For these reasons, despite most software today is distributed, the design and development of distributed systems remains surprisingly challenging.</p><p>We present the ScalaLoci distributed programming language, our approach for taming the complexity of developing distributed applications via specialized programming language support. ScalaLoci addresses the issues above with a coherent model based on placement types that enables reasoning about distributed data flows otherwise scattered across multiple modules, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions.</p><p>ScalaLoci does not force developers to modularize software along network boundaries as is traditionally the case when developing distributed systems. Instead, we propose a module system that supports encapsulating each (cross-host) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of ScalaLoci modules, each representing a subsystem.</p><p>Our case studies on distributed algorithms, distributed data structures, as well as on real-world distributed streaming engines show that ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs. As we demonstrate, the ScalaLoci module system allows the definition of reusable patterns of interaction in distributed software and enables separating the modularization and distribution concerns, properly separating functionalities in distributed systems.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Blöcher:2019:Grass" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">REBLS</abbr><br />
              
          
          
      </div>
      <div class="title">GRASS: Generic Reactive Application-Specific Scheduling</div>
      <div class="author">
        
          
          
          
          

          
            
              Marcel Blöcher, 
            
          
        
          
          
          
          

          
            
              Matthias Eichholz, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Patrick Eugster, 
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 6th ACM SIGPLAN International Workshop on Reactive and Event-Based Languages and Systems</em>, REBLS, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_GRASS-Generic-Reactive-Application-Specific-Scheduling.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3358503.3361274" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>High resource utilization is important to operate compute infrastructures and data centers efficiently. High utilization is achieved by multiplexing several applications over the same physical infrastructure. Yet, with this approach, the different requirements of each application have to be taken into account when scheduling resources.</p><p>We propose GRASS, a reactive domain-specific abstraction that allows specifying application-tailored resource scheduling policies. We demonstrate how the declarative approach of GRASS enables extension and composition of scheduling policies. Our evaluation shows the performance benefits of considering application-specific information in a composition of scheduling policies that adapt at run time.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Baumgärtner:2019:Smart" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">GHTC</abbr><br />
              
          
          
      </div>
      <div class="title">Smart Street Lights and Mobile Citizen Apps for Resilient Communication in a Digital City</div>
      <div class="author">
        
          
          
          
          

          
            
              Lars Baumgärtner, 
            
          
        
          
          
          
          

          
            
              Jonas Höchst, 
            
          
        
          
          
          
          

          
            
              Patrick Lampe, 
            
          
        
          
          
          
          

          
            
              Ragnar Mogk, 
            
          
        
          
          
          
          

          
            
              Artur Sterz, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Mira Mezini, 
            
          
        
          
          
          
          

          
            
              Bernd Freisleben
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 2019 IEEE Global Humanitarian Technology Conference</em>, GHTC, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Smart-Street-Lights-and-Mobile-Citizen-Apps-for-Resilient-Communication-in-a-Digital-City.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/GHTC46095.2019.9033134" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>While information and communication technology is crucial for the operation of urban infrastructures and the well-being of its inhabitants, current technology is quite vulnerable to disruptions of various kinds. In future smart cities, a more resilient urban infrastructure is imperative to handle the increasing number of hazardous situations. We present a novel resilient communication approach based on smart street lights as part of the public infrastructure. It supports people in their everyday life and adapts its functionality to the challenges of emergency situations. Our approach relies on various environmental sensors and in-situ processing for automatic situation assessment, and a range of communication mechanisms for maintaining a communication network. Furthermore, resilience is not only achieved based on infrastructure deployed by a digital city’s municipality, but also based on integrating citizens through software that runs on their mobile devices. Web-based zero-installation and platform-agnostic apps can switch to device-to-device communication to continue benefiting people even during a disaster situation. Our approach, featuring a covert channel for professional responders and a zero-installation app, is evaluated through a prototypical implementation based on a commercially available street light.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2019:Multitier" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">ECOOP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multitier Modules</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 33rd European Conference on Object-Oriented Programming (ECOOP)</em>, Leibniz International Proceedings in Informatics (LIPIcs), 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Multitier-Modules.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.4230/LIPIcs.ECOOP.2019.3" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
      <a href="https://github.com/scala-loci" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
      <a href="https://scala-loci.github.io/" class="btn btn-sm z-depth-0" role="button" target="_blank">Website</a>
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Multitier programming languages address the complexity of developing distributed systems abstracting over low level implementation details such as data representation, serialization and network protocols. Since the functionalities of different peers can be defined in the same compilation unit, multitier languages do not force developers to modularize software along network boundaries. Unfortunately, combining the code for all tiers into the same compilation unit poses a scalability challenge or forces developers to resort to traditional modularization abstractions that are agnostic to the multitier nature of the language.</p><p>In this paper, we address this issue with a module system for multitier languages. Our module system supports encapsulating each (cross-peer) functionality and defining it over abstract peer types. As a result, we disentangle modularization and distribution and we enable the definition of a distributed system as a composition of multitier modules, each representing a subsystem. Our case studies on distributed algorithms, distributed data structures, as well as on the Apache Flink task distribution system, show that multitier modules allow the definition of reusable (abstract) patterns of interaction in distributed software and enable separating the modularization and distribution concerns, properly separating functionalities in distributed systems.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2019:Developing" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">DEBS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Tutorial: Developing Distributed Systems with Multitier Programming</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 13th ACM International Conference on Distributed and Event-Based Systems</em>, DEBS, 2019
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2019_Developing-Distributed-Systems-with-Multitier-Programming.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3328905.3332465" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Developing distributed systems is a complex task that requires to program different peers, often using several languages on different platforms, writing communication code and handling data serialization and conversion.</p><p>We show how the multitier programming paradigm can alleviate these issues, supporting a development model where all peers in the system can be written in the same language and coexist in the same compilation units, communication code is automatically inserted by the compiler and the language abstracts over data conversion and serialization. We present multitier programming abstractions, discuss their applicability step by step for the development of small applications and discuss larger case studies on distributed stream processing, like Apache Flink and Apache Gearpump.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2018:Distributed" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">OOPSLA</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Distributed System Development with ScalaLoci</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/koehler">Mirko Köhler</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        <em>Proceedings of the ACM on Programming Languages</em> 2 (OOPSLA), 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_Distributed-System-Development-with-ScalaLoci.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3276499" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
      <a href="https://github.com/scala-loci" class="btn btn-sm z-depth-0" role="button" target="_blank">Code</a>
    
    
    
    
      <a href="https://scala-loci.github.io/" class="btn btn-sm z-depth-0" role="button" target="_blank">Website</a>
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed applications are traditionally developed as separate modules, often in different languages, which react to events, like user input, and in turn produce new events for the other modules. Separation into components requires time-consuming integration. Manual implementation of communication forces programmers to deal with low-level details. The combination of the two results in obscure distributed data flows scattered among multiple modules, hindering reasoning about the system as a whole. The ScalaLoci distributed programming language addresses these issues with a coherent model based on placement types that enables reasoning about distributed data flows, supporting multiple software architectures via dedicated language features and abstracting over low-level communication details and data conversions. As we show, ScalaLoci simplifies developing distributed systems, reduces error-prone communication code and favors early detection of bugs.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2018:Static" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">FTfJP</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Static Latency Tracking with Placement Types</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Tobias Reinhard, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings for the ISSTA/ECOOP 2018 Workshops</em>, ISSTA/ECOOP Companion, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_Static-Latency-Tracking-with-Placement-Types.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3236454.3236486" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Large-scale distributed applications, e.g., in geodistributed data centers, pose a performance challenge to developers which need to take high cross-data-center latency communication cost into account. We present a preliminary investigation of a type system that tracks latency and makes the cost of remote calls explicit, raising developers’ awareness of communication overhead.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Luthra:2018:TCEP" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">DEBS</abbr><br />
              
          
          
      </div>
      <div class="title">TCEP: Adapting to Dynamic User Environments by Enabling Transitions between Operator Placement Mechanisms</div>
      <div class="author">
        
          
          
          
          

          
            
              Manisha Luthra, 
            
          
        
          
          
          
          

          
            
              Boris Koldehofe, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>,
            
          
        
          
          
          
          

          
            
              Raheel Arif
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 12th ACM International Conference on Distributed and Event-Based Systems</em>, DEBS, 2018
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2018_TCEP-Adapting-to-Dynamic-User-Environments-by-Enabling-Transitions-between-Operator-Placement-Mechanisms.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/3210284.3210292" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Operator placement has a profound impact on the performance of a distributed complex event processing system (DCEP). Since the behavior of a placement mechanism strongly depends on its environment; a single placement mechanism is often not enough to fulfill stringent performance requirements under environmental changes. In this paper, we show how DCEP can benefit from the adaptive use of multiple placement mechanisms. We propose TCEP, a DCEP system to integrate multiple placement mechanisms. By enabling transitions, TCEP can seamlessly exchange distinct operator mechanisms at runtime. We make two main contributions that are highly important for a cost-efficient transition: i) a transition strategy for efficiently scheduling state migrations and ii) a lightweight learning algorithm to adaptively select an appropriate placement mechanism as a consequence of a transition. Our evaluations for important decentralized placement mechanisms in the context of an IoT scenario show that transitions can better fulfill QoS demands in a dynamic environment. Thereby efficient scheduling of state migrations can help to faster complete transitions by up to 94 %.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2017:QualityAware" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SEAMS</abbr><br />
              
          
          
      </div>
      <div class="title">Quality-Aware Runtime Adaptation in Complex Event Processing</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>,
            
          
        
          
          
          
          

          
            
              Manisha Luthra, 
            
          
        
          
          
          
          

          
            
              Boris Koldehofe, 
            
          
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/salvaneschi">Guido Salvaneschi</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Proceedings of the 12th International Symposium on Software Engineering for Adaptive and Self-Managing Systems</em>, SEAMS, 2017
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2017_Quality-aware-runtime-adaptation-in-complex-event-processing.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1109/SEAMS.2017.10" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Complex event processing (CEP) is a fundamental paradigm for a software system to self-adapt to environmental changes. CEP provides efficient means to detect (complex) events corresponding to environmental changes by performing a real-time analysis on many, possibly heterogeneous, data sources. The way current CEP systems detect events is determined at design time without accounting for dynamic changes of the environment monitored by the CEP system. This can lead to situations where the performance, quality and reliability of event detection significantly drop (e.g., due to mobility) since initial assumptions of the environment are violated or stated too general. In this paper, we propose AdaptiveCEP, a CEP system that is able to self-adapt to detected changes in environmental conditions. We propose a CEP query language that allows specifying changes in the behavior of the CEP system and its mechanisms in detecting events dependent on environmental conditions. This way, AdaptiveCEP can select the best-suited configurations for given quality demands. In our evaluation, we show by means of a reference concept how the flexibility exposed by the query language helps to achieve significant performance gains.</p>
    </div>
    
  </div>
</div>
</li>
<li><div class="row">


  <div id="Weisenburger:2016:Multitier" class="col-sm-12">
    
      <div class="abbr">
          
              
                <abbr class="badge">SPLASH DS</abbr><br />
              
          
          
                
                
                    
                    
                    
                        <abbr class="badge project"><a href="/projects/scala-loci">ScalaLoci <i class="fas fa-external-link-alt"></i></a></abbr><br />
                    
                
          
      </div>
      <div class="title">Multitier Reactive Abstractions</div>
      <div class="author">
        
          
          
          
          
            
              
                
                
          

          
            
              <a href="/members/weisenburger">Pascal Weisenburger</a>
            
          
        
      </div>

      <div class="periodical">
      
        In <em>Companion Proceedings of the 2016 ACM SIGPLAN International Conference on Systems, Programming, Languages and Applications: Software for Humanity</em>, SPLASH Companion, 2016
      
      </div>
    

    <div class="links">
    
      <a class="abstract btn btn-sm z-depth-0" role="button">Abstract</a>
    
    
      
        <a href="/assets/pdf/papers/2016_Multitier-Reactive-Abstractions.pdf" class="btn btn-sm z-depth-0" role="button" target="_blank">PDF</a>
      
    
    
      <a href="https://doi.org/10.1145/2984043.2984051" class="btn btn-sm z-depth-0" role="button" target="_blank"><i class="fas fa-external-link-alt"></i></a>
    
    
    
    
    
    
    
    
    </div>

    <!-- Hidden abstract block -->
    
    <div class="abstract hidden">
      <p>Distributed applications are traditionally developed using separate modules for each component in the distributed system, which can even be written in different programming languages. Those modules react on events such as user input, which are produced by other modules, and may in turn produce new events to be handled by different modules. Thus, most distributed applications are reactive in nature. Distributed event-based data flow makes it is hard to reason about the system and therefore makes the development of distributed systems challenging. In this paper, we present language abstractions for distributed reactive programming easing the development of such applications and supporting various distributed architectures.</p>
    </div>
    
  </div>
</div>
</li></ol>
      </div>
    
  </article>

</div>

    </div>

    <!-- Footer -->

    
<footer class="sticky-bottom mt-5">
  <div class="container">
    &copy; Copyright 2021   Programming Group.
    
    
    <a href="https://programming-group.com/impressum">Impressum</a>.
    
    
    Last updated: December 06, 2021.
    
  </div>
</footer>



    <script type="text/javascript" src="/assets/css/bundle-f83a6549c9380ccdc3ff0fc271d913db.js"></script>
  </body>
</html>
